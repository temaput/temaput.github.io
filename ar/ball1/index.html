<!DOCTYPE html>

<html>

<head>
    <title>Example 01.02 - First Scene</title>
    <script type="text/javascript" src="js/libs/three.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/loaders/GLTFLoader.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/libs/dat.gui.min.js"></script>
    <script src="js/libs/ar.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">
    // once everything is loaded, we run our Three.js stuff.
    function init() {
        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();
        // create a camera, which defines where we're looking at.
        var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        scene.add(camera);

        var camHelper = new THREE.CameraHelper(camera);
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({alpha: true});
        renderer.setClearColor(0xCCCCCC, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
    /*
        renderer.physicallyCorrectLights = true;
        renderer.gammaOutput = true;
        renderer.gammaFactor = 2.2;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        //renderer.shadowMap.enabled = true;
        renderer.setPixelRatio( window.devicePixelRatio );

        */


        // controls
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.autoRotate = false;
        controls.autoRotateSpeed = -10;
        controls.screenSpacePanning = true;


    	// array of functions for the rendering loop


	////////////////////////////////////////////////////////////////////////////////
	//          handle arToolkitSource
	////////////////////////////////////////////////////////////////////////////////
	var arToolkitSource = new THREEx.ArToolkitSource({
		// to read from the webcam
		sourceType : 'webcam',
		// to read from an image
		// sourceType : 'image',
		// sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/images/img.jpg',
		// to read from a video
		// sourceType : 'video',
		// sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
	})
	arToolkitSource.init(function onReady(){
		onResize()
	})



	////////////////////////////////////////////////////////////////////////////////
	//          initialize arToolkitContext
	////////////////////////////////////////////////////////////////////////////////

	// create atToolkitContext
	var arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: 'camera_para.dat',
		detectionMode: 'mono',
		maxDetectionRate: 30,
		canvasWidth: 80*3,
		canvasHeight: 60*3,
	})
	// initialize it
	arToolkitContext.init(function onCompleted(){
		// copy projection matrix to camera
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
	})





	////////////////////////////////////////////////////////////////////////////////
	//          Create a ArMarkerControls
	////////////////////////////////////////////////////////////////////////////////

	var markerRoot = new THREE.Group
	scene.add(markerRoot)
	var artoolkitMarker = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
		type : 'pattern',
		patternUrl : 'hiro.patt'
		// patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji'
	})
	// build a smoothedControls
	var smoothedRoot = new THREE.Group()
	scene.add(smoothedRoot)
	var smoothedControls = new THREEx.ArSmoothedControls(smoothedRoot, {
		lerpPosition: 0.4,
		lerpQuaternion: 0.3,
		lerpScale: 1,
	})



	//////////////////////////////////////////////////////////////////////////////////
	//		add an object in the scene
	//////////////////////////////////////////////////////////////////////////////////
	var arWorldRoot = smoothedRoot;
    //addTest();

        // Instantiate a loader
        var loader = new THREE.GLTFLoader();

        loader.load(
                // resource URL
                'ball_gltf/ball.gltf',
                // called when the resource is loaded
                function ( gltf ) {


                gltf.animations; // Array<THREE.AnimationClip>
                gltf.scene; // THREE.Scene
                gltf.scenes; // Array<THREE.Scene>
                gltf.cameras; // Array<THREE.Camera>
                gltf.asset; // Object
                setContent(gltf.scene);

                },
                // called while loading is progressing
                function ( xhr ) {

                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                },
                // called when loading has errors
                function ( error ) {

                    console.log( 'An error happened' );

                }
        );


        // add the output of the renderer to the html element
        var container = document.getElementById("WebGL-output")
        container.appendChild(renderer.domElement);
        var stats = new Stats();
        container.appendChild(stats.dom);


        var controls = new function() {
            this.rotationSpeed = 0.02;
            this.bouncingSpeed = 0.03;
        }
        var gui = new dat.GUI();
        gui.add(controls, 'rotationSpeed', 0, 0.5);
        gui.add(controls, 'bouncingSpeed', 0, 0.5);



        function onResize() {
            arToolkitSource.onResize()
            arToolkitSource.copySizeTo(renderer.domElement)
            if( arToolkitContext.arController !== null ){
                arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
            }

            /*
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            */

        }

        function setContent(object) {
            object.updateMatrixWorld();
            const box = new THREE.Box3().setFromObject(object);
            const size = box.getSize(new THREE.Vector3()).length();
            const center = box.getCenter(new THREE.Vector3());

            object.position.x += (object.position.x - center.x);
            object.position.y += (object.position.y - center.y);
            object.position.z += (object.position.z - center.z);
            object.scale.x = 10;
            object.scale.y = 10;
            object.scale.z = 10;

            /*
            controls.maxDistance = size * 10;
            camera.near = size / 100;
            camera.far = size * 100;
            camera.updateProjectionMatrix();


            camera.position.copy(center);
            camera.position.x += size / 2.0;
            camera.position.y += size / 5.0;
            camera.position.z += size / 2.0;
            camera.lookAt(center);
            */

            //controls.saveState();

            arWorldRoot.add(object);
            addLights();
        }

        function addLights() {
            const light1  = new THREE.AmbientLight(0xFFFFFF, 0.3);
            light1.name = 'ambient_light';
            camera.add( light1 );
            const light2  = new THREE.DirectionalLight(0xFFFFFF, 0.3 * Math.PI);
            light2.position.set(0.5, 0, 0.866); // ~60ยบ
            light2.name = 'main_light';

            camera.add( light2 );

        }


        function addTest() {
            	// add a torus knot
            var geometry	= new THREE.CubeGeometry(1,1,1);
            var material	= new THREE.MeshNormalMaterial({
                transparent : true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            var mesh	= new THREE.Mesh( geometry, material );
            mesh.position.y	= geometry.parameters.height/2
            arWorldRoot.add( mesh );

            var geometry	= new THREE.TorusKnotGeometry(0.3,0.1,64,16);
            var material	= new THREE.MeshNormalMaterial();
            var mesh	= new THREE.Mesh( geometry, material );
            mesh.position.y	= 0.5
            arWorldRoot.add( mesh );
        }

        // render the scene
        function renderScene() {

            requestAnimationFrame(renderScene);

            stats.update();
            if( arToolkitSource.ready ) {
                arToolkitContext.update( arToolkitSource.domElement );
            }
            smoothedControls.update(markerRoot);


            renderer.render(scene, camera);
        }
        renderScene();
        window.addEventListener('resize', onResize, false);
    }

    window.onload = init;
</script>
</body>
</html>
